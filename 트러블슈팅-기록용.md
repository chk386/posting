# Spring 이벤트 리스터에서 Coroutine Scope 공유로 인한 이벤트 처리 실패 문제 해결(상품-옵션 사례)

**2023년 6월 16일 작성**

기존 코드의 문제는 하나의 이벤트 리스너에서 같은 코루틴 스코프로 자식 코루틴을 만들어 사용하는 방식 때문에 <strong><span style="color:#e11d21;">다른 이벤트가 처리되지 않는 문제</span></strong><span style="">가 발생.</span>

### 같은 코루틴 스코프 코루틴 생성

`OptionEventListener.kt` 파일에 기존 구성된 코드를 보면 아래와 같다.

```kotlin
class OptionEventListener(
        threadPoolComponent: ThreadPoolComponent,
    ) {
        // 코루틴 스코프 생성
        private val eventCoroutineScope = CoroutineScope(threadPoolComponent.eventDispatcher)

        @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
        fun createOptionHistory(event: OptionCUEvent) {
            eventCoroutineScope.launch {
                transaction.runInTransaction {
                    // this.isActive
                }

                syncSlaveOption(event.updatedOptions)
            }
        }

        @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
        fun createDeletedOptionHistory(event: OptionDeleteEvent) {

            eventCoroutineScope.launch {
                transaction.runInTransaction {
                    // this.isActive
                }
            }
        }
```

위 코드에서 문제는 서로 다른 이벤트끼리 연결 될 수 있다.

- 하나의 스코프(부모 코루틴)에 각각 1번 코루틴 자식, 2번 코루틴 자식이 생성된다.
  - 1번 이벤트와 2번 이벤트가 부모 스코프를 통해 서로 연결된다.
  - 이 경우, 1번과 2번 중 하나라도 예외가 발생하면 나머지 하나는 동작하지 않는다.
  - 예를 들어 1번 이벤트 코루틴에서 로직 수행 중, 예외가 발생하면 해당 스코프의 `isActive`(현재 코루틴 job의 활성화 상태)이 false가 되고, 다른 자식 코루틴은 모두 취소된다.

### SuperviorJob와 디스패처를 추가한 동일한 코루틴 스코프로 코루틴 생성

SuperviorJob으로 1번 상황에서 서로 다른 이벤트끼리 연결이 되는 것은 끊었더라도, 또 다른 문제가 발생할 여지가 있다.
`ProductEventListener.kt` 파일 등의 예시 코드를 살펴보면 아래와 같이 구성되어있습니다.

```kotlin
class ProductEventListener(
        threadPoolComponent: ThreadPoolComponent,
    ) {
        // 코루틴 스코프 생성
        private val eventCoroutineScope = CoroutineScope(SupervisorJob() + threadPoolComponent.eventDispatcher)

        @EventListener
        fun firstEvent(event: FirstEvent) {
            eventCoroutineScope.launch {
                // A 로직 수행
            }
        }

        @EventListener
        fun secondEvent(event: SecondEvent) {
            eventCoroutineScope.launch {
                // B 로직 수행
            }
        }
    }
```

- 위 코드에서도 마찬가지로 부모 스코프 하나가 취소되면, 해당 스코프 내에 있는 모든 이벤트가 로직을 수행하지 않게 됩니다.
- 서로 다른 요청을 통해 처리되는 각각의 이벤트인 경우, 위처럼 하나에 종속된 것보다는 다른 코루틴 스코프를 생성하여 처리하는게 좋습니다.

### Noncancellable을 활용, 부모 스코프의 active 유무에 상관없이 이벤트를 처리하거나 이벤트 별로 스코프를 따로 사용하도록 변경

#### NonCancellable

```kotlin
class ProductEventListener(
        threadPoolComponent: ThreadPoolComponent,
    ) {
        // 코루틴 스코프 생성
        private val eventCoroutineScope = CoroutineScope(NonCancellable + threadPoolComponent.eventDispatcher)
    }
```

- NonCancellable은 해당 job의 active 상태를 항상 true 값으로 유지
- CancellableException에 영향을 받지 않고, 코드를 실행해야할 때 사용.

#### 서로 다른 코루틴 스코프 생성

```kotlin
class ProductEventListener(
        private val threadPoolComponent: ThreadPoolComponent,
    ) {
        @EventListener
        fun subscribeProductEvent(event: ProductEvent) {
            CoroutineScope(threadPoolComponent.eventDispatcher).launch {
                // ...
            }
        }

        @EventListener
        fun handleProductNotification(event: ProductEvent) {
            CoroutineScope(threadPoolComponent.eventDispatcher).launch {
                // ...
            }
        }
    }
```

- 위의 경우에는 scope를 개별로 생성 후, 로직을 처리하기 때문에 이벤트 간 연관관계 X
